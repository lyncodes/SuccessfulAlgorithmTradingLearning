# Event Driving Engine
## Components
- Event
  - the most fundamental unit of the event
  - it contains the type(such as "MARKET","SIGNAL","ORDER","FILL")
  - the event type determines how the event will be processed inside the **event-loop**
- Event Queue
  - In-Memory python Queue object that stores all Event which generated by the rest parts
  of the trading system
  - (_maybe in larger system, it can has several Queue for different purpose._)
- Data Handler
  - abstract base class
  - for handle both the **living market data** and the **historical data**
  - datahandler generates new MarketEvent every **heartbeat** of the system
- Strategy
  - also the ABC for both handling the living market data and historical backtesting
  - generating the SignalEvent
  - SignalEvent contains the **ticker symbol,trading direcion(LONG,SHORT),timestamp,and other extensieve** purpose
- Portfolio
  - takes **SignalEvents** from the **Queue** and generates **OrderEvents** that get added to the Queue.
- Execution Handler
  - take OrderEvents,then simulated it or send it to the living brokerage
  - once the orders are executed, the handler will generate the FillEvent
  - FillEvent contains the information:
    - what was actually transacted
    - transaction fees
    - commission
    - slippage
- Backtest
  - simulated things above
  
## Event
4 types basic event type including  **MarketEvent, SignalEvent, OrderEvent and FillEvent.**

``Event``
the base Event class for inherited
```python
class Event(object):
    """
    Event is base class,which will be inherited in the latter specified deritive 
    Event
    """
    pass
```
``MarketEvent``
derive from the base event class
```python
class MarketEvent(Event):
    """
    triggered by the datahandler which recieve data feed from vendor
    trigger the strategy to generating trading strategy
    """
    def __init__(self):
      """
      Initialises the MarketEvent.
      """
        self.type = 'MARKET'

```
``SignalEvent``
SignalEvent generated by the strategy according the market data
```python
class SignalEvent(Event):
    """
    handle event and generate signal to portfolio object
    """
    def __init__(self, strategy_id,symbol,datetime,signal_type,strength):
        '''
            strategy_id: the unique identifier for the strategy
            symbol: the ticker symbol e.g. 'GOOG' 'rb1905'
            datetime: the timestamp which the signal was generated
            signal_type: 'LONG' or 'SHORT'
            strength: scale the quantity at the portfolio level
        '''

        self.type = 'SIGNAL'
        self.strategy_id = strategy_id
        self.symbol = symbol
        self.datetime = datetime
        self.signal_type = signal_type
        self.strength = strength
```
``OrderEvent``
a Portdolio object receives SignalEvents, then generate the OrderEvent, pass order to an ExecutionHandler
```python
class OrderEvent(Event):
    '''
    handle the order
    '''

    def __init__(self, symbol, order_type, quantity, direction):
        """

        :param symbol:e.g.(GOOG,RB1906) instrument to trade
        :param order_type: market or limit, MKT or LMT
        :param quantity: how much we trade, non-negative integer
        :param direction: LONG or SHORT
        """
        self.type = 'ORDER'
        self.symbol = symbol
        self.order_type = order_type
        self.quantity = quantity
        self.direction = direction

    def print_order(self):
        print("Order: Symbol=%s, Type=%s, Quantity=%s, Direction=%s" %
              (self.symbol, self.order_type, self.quantity, self.direction)
              )   
```
``FillEvent``
an order has been transacted, it generated a FillEvent describe the details information about the transaction
```python
class FillEvent(Event):
    """
    store the information returns from the broker
    quantity of an instrument actually filled and what price
    the commission and other cost
    """

    def __init__(self, timeindex, symbol, exchange, quantity, direction, fill_cost, commission=None):
        """

        :param timeindex: bar-resolution when the order was filled
        :param symbol: instrument symbol
        :param exchange: which exchange
        :param quantity: how much been traded
        :param direction: LONG or SHORT
        :param fill_cost: holding value
        :param commission: optional commission sent from the broker
        """
        self.timeindex = timeindex
        self.symbol = symbol
        self.exchange = exchange
        self.quantity = quantity
        self.direction = direction
        self.fill_cost = fill_cost

        if commission:
            self.commission = commission
        else:
            self.commission = self.calculate_commission()

    def calculate_commission(self):
        """
        calculate the commission according
        specific rules
        :return: commission

        example purpose only
        """
        commission = 1.3
        if self.quantity <= 500:
            commission = max(1.3, 0.013 * self.quantity)
        else:
            commission = max(1.3, 0.008 * self.quantity)
        return commission
```

## DataHandle
event-driven system need data handler both for backtesting and living trading.

several type of data handlers including:
 - HistoricCSVDataHandler
 - DataBaseDataHandler
 - OnlineDataHandler
 - MarketDataHandler
 - others....
 
 ``DataHandler``
 the abstract base class is a interface for the various data handlers.
 ```python
class DataHandler(ABC):
    """
    ABC means that is can not be instantiate an instance directly
    only subclasses can be instantiated
    reason for this:
        all subsequent DataHandler subclasses must adhere to thereby
        ensuring the compatibility with other classes that comminicate with each other

    Derived class DataHandler object can generate set of bars(OHLCVI) for each symbol.
    """

    # abstractmethod will let the interpreter know this function
    # will be overridden in subclasses
    @abstractmethod
    def get_latest_bars(self, symbol, n=1):
        """
        :param n:
        :return:
        """
        raise NotImplementedError("not implemented")

    @abstractmethod
    def get_latest_bar_datetime(self, symbol):
        """

        :param symbol:
        :return:
        """
        raise NotImplementedError("not implemented")

    @abstractmethod
    def get_latest_bar_value(self, symbol, value_type=None):
        """
        :param n:
        :param value_type:
        :return:
        """
        raise NotImplementedError("not implemented")

    @abstractmethod
    def update_bars(self):
        """
        :return:
        """
        raise NotImplementedError("not implemented")
```

``HistoricCSVDataHandler``
```python
class HistoricCSVDataHandler(DataHandler):
    """
    read CSV files
    """

    def __init__(self, events:Queue, csv_dir:str, symbol_list:list):
        """
        :param events: The Event Queue
        :param csv_dir: Directory path to the CSV files.
        :param symbol_list: A list of symbol strings.
        """
        self.event = events
        self.csv_dir = csv_dir
        self.symbol_list = symbol_list

        self.symbol_data = {}
        self.latest_symbol_data = {}
        self.continue_backtest = True

        self._open_convert_csv_files()

    def _open_convert_csv_files(self):
        """
        open csv files and convert them into pandas dataframe
        :return:
        """
        comb_index = None
        for symbol in self.symbol_list:
            # read all csv files into a single one dict,this dict is a member variable
            # dict keys are string, values are dataframe
            self.symbol_data[symbol] = pd.read_csv(os.path.join(self.csv_dir, '%symbol.csv' % symbol),
                                                   header=0, index_col=0, parse_dates=True,
                                                   names=['datetime', 'open', 'high', 'low', 'close',
                                                          'volume', 'adj_close']).sort()
            if comb_index is None:
                comb_index = self.symbol_data[symbol].index
            else:
                comb_index.union(self.symbol_data[symbol].index)

            self.latest_symbol_data[symbol] = []
        # reindex the dataframe
        for symbol in self.symbol_list:
            self.symbol_data[symbol] = self.symbol_data[symbol].reindex(index=comb_index,
                                                                        method='pad').iterrows()

    def _get_new_bar(self, symbol):
        """
        a generator to provide a new bar
        :param symbol: instrument symbol
        :return: the latest bar from the data feed
        """
        for bar in self.symbol_data[symbol]:
            yield bar  # generator

    def get_latest_bars(self, symbol, n=1):
        """
        return the last n bars from the latest_symbol list
        :param symbol:
        :param n:
        :return:
        """
        bar_list = self.latest_symbol_data[symbol]
        return bar_list[-n:]

    def get_latest_bar_datetime(self, symbol):
        """

        :param symbol:
        :return:
        """
        bar_list = self.latest_symbol_data[symbol]
        return bar_list[-1][0]

    def get_latest_bar_value(self, symbol, value_type=None, n=1):
        """
        :param symbol:
        :param value_type:
        :return: open,high,low,close,volume,oi values from the pandas bar series object
        """
        bar_list = self.get_latest_bars(symbol, n)
        return [getattr(bar[1],value_type) for bar in bar_list]

    def update_bars(self):
        """

        :return:
        """
        for symbol in self.symbol_list:
            bar = next(self._get_new_bar(symbol))
            if bar is not None:
                self.latest_symbol_data[symbol].append(bar)

        self.event.put(MarketEvent())
```
derived class overriden the existed functions, implemented the specific functions.

## Stratgy
- strategy object encapsulates the **calculations** on the market data
- send trading signals to the ``Portfolio`` object
- seperate the strategy and portfolio is more amendable for multiple strategy,
**in turn to lower the risk**

strategy hierarchy is relatively simple, also consists of an abstract base class 
which to generate the SignalEvent
``Strategy``
```python
from abc import ABC,abstractmethod
import datetime
from queue import Queue
import numpy as np
import pandas as pd
from EventType import SignalEvent

class Strategy(ABC):
    """
    Strategy is an abstract base class for the subsequent subclass
    that generate SignalEvent which will be send to Portfolio object

    DataHandler generate Bars(MarketEvent),Strategy recieve Bars then generate signals(SignalEvent)
    """
    @abstractmethod
    def calculate_signal(self):
        """
        calculate the list of signals
        :return:
        """
        raise NotImplementedError("not implemented")


```

## Portfolio
A Portfolio object track the **positions** within a portfolio
and **generates orders** of a fixed quantity of stock based on signals

**OMS**(order management system) is the **most complex** part of the even-driven system
- role:
  - keep track of all current market positions and the market value

- functionalities:
  - handle ``SignalEvent``
  - generate ``OrderEvent`` and sent it to brokers
  - interpret ``FillEvent`` to update positions
no surprise the ``Portfolio`` is the largest component of the Event-Driven System

